'''
问题描述
　　在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式
　　包含一个正整数n
输出格式
　　一个整数，表示放置车的方法数
样例输入
2
样例输出
7
【样例解释】一个车都不放为1种，放置一个车有4种，放置2个车有2种。
只是不能上下左右响铃吗？，可以斜对角
'''
n = int(input())
v = [0 for _ in range(n)]
ans = 1


# 还是不熟悉
def dfs(row):
    global ans
    if row >= n:
        return

    # 注意下面是一种如果需要遍历行列的方式，很巧妙，这样可以避免多写一个for循环，

    for i in range(n):  # 这里就是列的遍历了
        if v[i] == 0:
            v[i] = 1
            ans += 1
            dfs(row + 1)
            v[i] = 0
    # 让每次dfs作为行的遍历循环，然后在dfs中进行列循环
    # 这里也难怪dfs会解决一些暴力的运行超时问题，减少一次循环直接
    # 网上还有一个同学用c++做的，就是两个循环，他也用到dfs了，但是就没那么精髓
    dfs(row + 1)


dfs(0)  # 从0开始就要条件 row >= n，同时在列的遍历中从 0 开始
print(ans)
