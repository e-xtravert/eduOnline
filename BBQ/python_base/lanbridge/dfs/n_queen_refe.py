'''
问题描述
　　在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。
你的任务是，对于给定的N，求出有多少种合法的放置方法。
输入格式
　　输入中有一个正整数N≤10，表示棋盘和皇后的数量
输出格式
　　为一个正整数，表示对应输入行的皇后的不同放置数量。
样例输入
5
样例输出
10
'''
# 把棋盘存储为一个N维数组a[N]，数组中第i个元素的值代表第i行的皇后位置, 其实就是保存第i行皇后的列数据，也就是说a[i] == column
# 改进之后特别快，就是没有答案
# debug了一下，发现是check函数中，循环的边界问题
# 不过这里还是dfs说白了是递归，如果要输出所有解，那由该如何做呢，敬请期待，这个代码我觉得还挺经典的，多看看
n = int(input())
board = [0 for _ in range(n)]  # 用一维数组去保存位置
res = 0


# 还是先写个判断条件函数，这个好写
def check(row, col):
    for i in range(row):  # 原来是这里写错了，这里应该是查看这行之前的，而不是所有，不然肯定有等于0 的呀，这一整行
        if (abs(row - i) == abs(board[i] - col)) or (board[i] == col):  # 为啥不判断行相同，可能是直接行 + 1 了吧
            return 0

    return 1  # 如果扫描完了还没有，那可能是皇后还没设置1， 直接给 1


def dfs(row):  # 是给第i行赋值列的值嘛，答案传了两个参数，我感觉不用吧，等一下分别测一下速度
    global res
    if row >= n:
        res += 1
        return

    for i in range(n):  # 这里其实就是每一列
        if check(row, i) == 1:
            board[row] = i
            dfs(row + 1)


dfs(0)
# print(n, board, res)
print(res)