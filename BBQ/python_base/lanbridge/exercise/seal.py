'''
蓝桥杯算法训练第一题
共有n种图案的印章，每种图案的出现概率相同。小A买了m张印章，求小A集齐n种印章的概率。
设dp[i][j]为i张印章，j种图案集齐的概率
当n<m时，概率为0。
由于每种图案的出现概率相同，所以每种图案的概率：1/n
设i为购买了i张印章，j为集齐j种
若j=1，即：购买了i张印章，集齐了一种图案，概率为(1/n)^(i-1)，(因为还剩下i-1张印章的图案不确定，又因为每个图案的概率为1/n)
若j!=1时，即：购买了i张印章，集齐了j种，分为两种情况：
第一种：前i-1张已经集齐了j种图案
	该情况，第i张印章只能是重复的图案，即：只能是j种图案中的一种，同时j种重复图案的概率为j*(1/n)，因此该情况的概率为dp[i-1][j]*j*(1/n)
第二种：前i-1张只集齐了j-1种图案
	该情况，第i张印章图案只能是n种图案中排除j-1种图案余下的图案，概率为[n-(j-1)](1/n)，因此该情况的概率为dp[i-1][j-1]*[n-(j-1)](1/n)
'''
import math
# n种图案，买了m张牌
# 集齐了j种，买了i张牌
n, m = map(int, input().split())
# dp = [[0] * (n + 1)] * (m + 1)  # 终于知道为什么了，这样的话，他等于是把dp[[0] * (n + 1)]]复制了 (m + 1) 份，初始化还是要用下面的方法
dp = [[0] * (n + 1) for _ in range(m + 1)]
# p = 1.0 // n  # 这里直接向下取整了，怪不得没有数据，全是0，要用一个斜杠，这里是需要小数的
p = 1 / n
# 假设购买了i张印章，集齐了j张
# 概率从还需要集齐什么图案去考虑
for i in range(1, m + 1):  # m张印章
    for j in range(1, n + 1):  # n种图案
        if i < j:
            dp[i][j] = 0
        if j == 1:
            dp[i][j] = p ** (i - 1)  # 两个*表示乘方
            # for t in range(i - 1):
            # dp[i][j] = math.pow(p, i - 1)
        else:
            dp[i][j] = dp[i - 1][j] * j * p + dp[i - 1][j - 1] * (n - j + 1) * p

# print(n, m, f"{dp[m][n]: .4f}")
print("%.4f" % dp[m][n])  # 第一次提交有一个空格多， 注意引号里面的百分号后面不要加空格
# print(dp)
